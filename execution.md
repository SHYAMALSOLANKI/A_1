# PB2S Execution Plan: "Neuro-Symbolic Emergence"

## 1. Objective
Replace the static dataset generation with a **Live Stack Server** that implements the PB2S (Prompt-Based 2-System) reasoning architecture.
This server will orchestrate the `Draft -> Audit -> Revise` loop in real-time.

## 2. Directory Structure
We will create a new microservice `services/stack_server` that sits alongside `services/trainer` and `services/orchestrator`.

```
services/stack_server/
├── __init__.py
├── api.py           # The FastAPI entry point (The "Brain")
├── config.py        # Configuration (DB URLs, Model Paths)
├── cae.py           # Contradiction Audit Engine (Logic/Math/Regex)
├── irq.py           # Interactive Response Queue (Translator)
├── pps.py           # Persistent Prompt Stack (Constitution)
├── main.py          # Entry point for "Self-Play" Simulation loops
└── resources/
    └── core_policy.json  # The "Constitution" file
```

## 3. Component Design

### A. PPS (Persistent Prompt Stack) - `pps.py`
**Role**: The Constitution.
**Content**:
- **Identity Rules**: "You are a reasoner, not a predictor."
- **Safety Rules**: "No hate speech, no self-harm."
- **Logic Rules**: "A cannot be True and False simultaneously."
**Implementation**:
- Loads `core_policy.json` on startup.
- Provides `get_active_policies()` based on context (e.g., math context gets math rules).

### B. CAE (Contradiction Audit Engine) - `cae.py`
**Role**: The Auditor (System 2).
**Logic**:
- **Syntax Check**: Uses Regex to ensure `DRAFT:`, `REFLECT:`, `REVISE:` structure exists.
- **Math Check**: Extracts equations (e.g., `2 + 2 = 5`) and verifies them using `sympy`.
- **Grammar & Style Gate**: Uses `language-tool-python` to detect actionable grammar errors and `textstat` for readability (Flesch-Kincaid). Complex text is flagged for simplification.
- **Contradiction Gate (Logic)**: Uses `sentence-transformers` (Cross-Encoder NLI) to detect semantic contradictions between sentences.
- **Output**: Returns a `ViolationReport` object (list of errors).

### C. IRQ (Interactive Response Queue) - `irq.py`
**Role**: The Teacher.
**Logic**:
- Takes `ViolationReport` from CAE.
- **Injects**: Constructs the `REFLECT` prompt.
  - *Input*: `Violation(type="Math", detail="2+2!=5")`
  - *Output*: `"REFLECT: The draft contains a calculation error. 2+2 equals 4, not 5. Correct this in the revision."`

### D. The Brain (API) - `api.py`
**Role**: The State Machine.
**Flow**:
1. `POST /generate`: User sends "Explain Gravity".
2. **Draft Phase**: Call LLM -> Get `Draft`.
3. **Audit Phase**: Call `CAE.audit(Draft)`.
4. **Pass/Fail**:
   - If Pass: Return Draft.
   - If Fail:
     - **Reflect Phase**: Call `IRQ.translate(Violations)`.
     - **Revise Phase**: Call LLM with Injection -> Get `Revise`.
5. **Learn Phase**: Calculate `Draft` vs `Revise` distance. Save to DB.

## 4. Integration Plan (Docker)
The Docker screenshots show an existing `pb2s_agent_api` and `postgres`.
- We will add `stack_server` to `docker-compose.yml`.
- It will connect to the *same* `postgres` network to log traces.
- It will expose port `9000` for the Trainer to hit.

## 5. Execution Steps
1. **Define Core Policy**: Create `core_policy.json`.
2. **Setup Environment**: Create `requirements.txt` with `language-tool-python`, `textstat`, `sentence-transformers`, `sympy`, `pydantic`.
3. **Code the Logic**: Implement `cae.py` (Math/Regex/Grammar/NLI).
4. **Code the Bridge**: Implement `irq.py`.
5. **Api & Integration**: Write `api.py` using FastAPI.
5. **Self-Play Script**: Create `main.py` to run the loop without a user (Simulated Training).

## 6. Self-Play (Simulation Mode)
To replace the static dataset, we will run the server in `self-play` mode:
- It picks a random topic from a seed list.
- It generates a Draft.
- It (intentionally) finds flaws via strict CAE.
- It generates the Fix.
- **Result**: A live database of *perfect* reasoning traces, generated by the loop, not faked by a script.

## 7. Dynamic Trainer Integration (Phase 2)
1. **Dynamic Quality Controller (DQC)**: 
   - Implement `services/stack_server/quality.py` to adaptively scale difficulty (`beta`).
   - Expose `/quality` endpoint.
2. **Trainer Update**: 
   - Rewrite `services/trainer/train_drrl.py` to connect to `http://localhost:9000`.
   - Implement the `DRAFT -> AUDIT -> REFLECT -> REVISE` generation loop (Intervention Cycle).
   - Implement the hybrid loss function: `Loss = CE_Loss + (1-Score)*Beta + Gamma*Rev_Dist`.
3. **Execution**: 
   - Run `docker compose up` to start Stack Server (Rules Engine).
   - Run `python services/trainer/train_drrl.py` to start Self-Correcting Training.
